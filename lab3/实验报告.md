### 练习 1：理解基于 FIFO 的页面替换算法（思考题）

描述 FIFO 页面置换算法下，一个页面从被换入到被换出的过程中，会经过代码里哪些函数/宏的处理（或者说，需要调用哪些函数/宏），并用简单的一两句话描述每个函数在过程中做了什么？（为了方便同学们完成练习，所以实际上我们的项目代码和实验指导的还是略有不同，例如我们将 FIFO 页面置换算法头文件的大部分代码放在了 `kern/mm/swap_fifo.c` 文件中，这点请同学们注意）

- 至少正确指出 10 个不同的函数分别做了什么？如果少于 10 个将酌情扣分。我们认为只要函数原型不同，就算两个不同的函数。要求指出对执行过程有实际影响、删去后会导致输出结果不同的函数（例如 `assert`）而不是 `cprintf` 这样的函数。如果你选择的函数“不能完整地体现”从换入到换出的过程，比如 10 个函数都是页面换入的时候调用的，或者解释功能的时候只解释了这 10 个函数在页面换入时的功能，那么也会扣除一定的分数。

**答：**

当 CPU 想要访问某一个虚拟地址时，会经过 mmu 翻译，如果 mmu 在页表中没有找到映射的物理地址，就会触发异常，这个页面将会被换入。当之后有其他页面发生缺页异常并且内存不足时，会根据页面换出策略选择页面并将其换出。

- do_pgfault(...)：根据参数中的 error_code 和 addr 来解决缺页异常。
- find_vma(...)：在所有虚拟内存块中找到参数 addr 所在的合法的虚拟内存块，如果不存在则返回 null。
- #define ROUNDDOWN(a, n)：根据 n 的大小（4096）将虚拟地址 a 向下对齐，得到虚拟地址所在的页的起始地址。
- get_pte(...)：找到参数 la 所对应的页表项，如果涉及到的页目录项或页表项当前不存在，则会先创建再返回。
- swap_in(...)：将数据从硬盘加载到虚拟地址 addr 对应的物理内存中。
- page_insert(...)：在页表中填入虚拟地址到物理内存的映射关系，并刷新 TLB。
- page_remove_pte(...)：在页表中删除虚拟地址到物理内存的映射关系，如果页面的引用计数为 0，会释放页面的内存。
- swap_map_swappable(...)：设置页面可交换，即之后可以被选中并换出。
- swap_out(...)：在 alloc_pages(size_t n) 函数中被调用，如果分配内存不足，则会换出页面。这个函数将内存中的数据写回磁盘，并取消虚拟地址到物理内存的映射关系，刷新 TLB。
- swap_manager.swap_out_victim(...)：在 swap_out(...) 中被调用，用于根据设置的页面换出策略选择一个最适合被换出的页面。

### 练习 2：深入理解不同分页模式的工作原理（思考题）

`get_pte()` 函数（位于 `kern/mm/pmm.c`）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。

- `get_pte()` 函数中有两段形式类似的代码，结合 sv32、sv39、sv48 的异同，解释这两段代码为什么如此相像。
- 目前 `get_pte()` 函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

**答：**

当前的 ucore 使用的是 sv39 模式，即三级页表。两段相似的代码所作的工作分别为：在第一级页目录中查找第二级页目录项，如果不存在则分配内存并创建第二级页目录项；在第二级页目录项中查找第三级页表项，如果不存在则分配。两段代码相似是因为三级页表中每相邻两级的关系和管理方式是相似的。

将页表项的查找和页表项的分配合并在一个函数里，我认为是可以的，因为只在 `get_pte()` 一个函数中完成了寻找页表项的工作。如果将来需要扩展并支持 sv32、sv39、sv48 等多种模式，那么把两个功能拆开会更好，可以使代码更简洁，比如可以使用一个 while 循环递归地查找各级页目录，如果不存在则分配。

### 练习 3：给未被映射的地址映射上物理页（需要编程）

补充完成 `do_pgfault`（`mm/vmm.c`）函数，给未被映射的地址映射上物理页。设置访问权限的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制结构所指定的页表，而不是内核的页表。

请在实验报告中简要说明你的设计实现过程。请回答如下问题：

- 请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对 ucore 实现页替换算法的潜在用处。
- 如果 ucore 的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
  - 数据结构 Page 的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

**答：**

**页目录项和页表项的组成部分对实现页替换算法的潜在用处**：PDE 和 PTE 都包含若干标志位和物理地址信息。标志位比如 PTE_A 和 PTE_D 分别记录了页面的访问信息和是否被更改，可以用于 clock 页替换算法中寻找被换出的页面，并决定被换出时是否需要被写入磁盘。

**缺页异常的硬件处理**：当 ucore 中的缺页服务例程遇到页访问异常时，硬件会触发缺页异常中断，将异常信息（包括错误码和访问地址）保存到特定寄存器中（如 CR2 寄存器存储缺页地址），然后跳转到处理缺页异常的函数处。并且硬件在异常处理结束后，会重新执行引发缺页的指令。

**Page数组的每一项与页表中的 PDE 和 PTE 是否对应**：`Page` 数组中的每一项对应物理内存中的一个页面，`Page` 结构体中的数据结构描述了一个物理页帧的属性。通过 page2pa 函数可获取物理页地址，pte2page 则可从页表项获取对应 Page 结构体。

### 练习 4：补充完成 Clock 页替换算法（需要编程）

通过之前的练习，相信大家对 FIFO 的页面替换算法有了更深入的了解，现在请在我们给出的框架上，填写代码，实现 Clock 页替换算法（`mm/swap_clock.c`）。 （提示：要输出 `curr_ptr` 的值才能通过 `make grade`）

请在实验报告中简要说明你的设计实现过程。请回答如下问题：

- 比较 Clock 页替换算法和 FIFO 算法的不同。

**答：**

- FIFO算法：按照页面进入内存的顺序进行替换。最早进入的页面最先被替换，不考虑页面是否被访问过。
- Clock 算法：通过访问位来模拟 LRU 算法。页面被组织成环形链表，访问位为 1 的页面被跳过，访问位为 0 的页面被淘汰。

### 练习 5：阅读代码和实现手册，理解页表映射方式相关知识（思考题）

如果我们采用 “一个大页” 的页表映射方式，相比分级页表，有什么好处、优势，有什么坏处、风险？

**答：**

**优点：**
使用大页可以减少页表的层级，甚至可以不需要中间的页表，可以减少内存中用于存储页表的空间开销，并且可以减少查找页表项的时间开销，提升访存效率。

**缺点：**
大页分配内存的粒度较大，若映射的区域未被充分使用，会导致内存浪费，尤其是在需要小内存块的应用场景中。比如如果某个大页中仅有一部分是频繁访问的，那么整个大页都将保留在内存中，增加了内存的压力。并且使用大页会导致在发生缺页异常时需要处理的区域较大，使缺页异常的处理时间更长。

### 扩展练习 Challenge：实现不考虑实现开销和效率的 LRU 页替换算法（需要编程）

challenge 部分不是必做部分，不过在正确最后会酌情加分。需写出有详细的设计、分析和测试的实验报告。完成出色的可获得适当加分。

**答：**

